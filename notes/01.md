# 01 GO语言基础

## 2-1 变量定义
+ 声明变量时候，会自动为变量赋一个初值
+ 也可以不写类型，编译器会自动判断
+ 有几种赋值方法，见代码
+ 函数外面使用 := 不行
+ 没有全局变量 只是包级别的变量
```go
// 1
var (
	aa = 3
	ss = "kkk"
	bb = true
)
// 2
func variableZeroValue() {
	var a int
	var s string
	fmt.Printf("%d %q\n", a, s)
}
// 3
func variableInitialValue() {
	var a, b int = 3, 4
	var s string = "abc"
	fmt.Println(a, b, s)
}

func variableTypeDeduction() {
	var a, b, c, s = 3, 4, true, "def"
	fmt.Println(a, b, c, s)
}

func variableShorter() {
	a, b, c, s := 3, 4, true, "def"
	b = 5
	fmt.Println(a, b, c, s)
}
```

## 2-2 变量类型
### 变量类型一览
+ bool string
+ (u)int 8 16 32 64 uintptr
+ byte rune(32位，相当于其他语言的char)
+ float32 64 complex64 128（复数 实部float32 虚部float32）
```go
//欧拉公式验证函数（复数）
func euler() {
	fmt.Printf("%.3f\n",
		cmplx.Exp(1i*math.Pi)+1)
}
```
### 类型转换
只有强制类型转换，不能隐式转换
```go
//勾股定理 验证强制类型转换
func triangle() {
	var a, b int = 3, 4
	fmt.Println(calcTriangle(a, b))
}

func calcTriangle(a, b int) int {
	var c int
	c = int(math.Sqrt(float64(a*a + b*b)))
	return c
}
```
## 2-3 常量
### 常量声明与使用
- 常量的声明和var差不多 不过要用const
- 数值常量可以作为各种类型使用
```go
func consts() {
	const (
		filename = "abc.txt"
		a, b     = 3, 4
	)
	var c int
	c = int(math.Sqrt(a*a + b*b))
	fmt.Println(filename, c)
}
```
### 枚举类型（自增类型的枚举类型）
- 使用const()声明一些变量
- 可以用iota简化代码，iota是定义自增的一个表达式
```go
func enums() {
	const (
		cpp = iota
		_
		python
		golang
		javascript
	)

	const (
		b = 1 << (10 * iota)
		kb
		mb
		gb
		tb
		pb
	)

	fmt.Println(cpp, javascript, python, golang)
	fmt.Println(b, kb, mb, gb, tb, pb)
}
```

## 条件语句
### if
- if 后面可以跟表达式，赋值操作
- 作用域在if语句块
```go
const filename = "abc.txt"
if contents, err := ioutil.ReadFile(filename); err != nil {
	fmt.Println(err)
} else {
	fmt.Printf("%s\n", contents)
}
```
### switch
- go自动break，如果需要执行后面的，用fallthrough
- swithch 后面可以没有表达式,它会匹配true
- case后的常量值不能重复 
- case后可以有多个常量值 
- fallthrough应该是某个case的最后一行。如果它出现在中间的某个地方，编译器就会抛出错误。
```go
func grade(score int) string {
	g := ""
	switch {
	case score < 0 || score > 100:
		panic(fmt.Sprintf(
			"Wrong score: %d", score))
	case score < 60:
		g = "F"
	case score < 80:
		g = "C"
	case score < 90:
		g = "B"
	case score <= 100:
		g = "A"
	}
	return g
}
```
type switch使用方法，它比较的是类型而不是具体的值。它判断某个接口变量的类型，然后根据具体类型再做相应处理。注意，在type switch语句的case子句中不能使用fallthrough。
```go
	var x interface{}

	switch i := x.(type) {
	case nil:
		fmt.Printf(" x 的类型 :%T", i)
	case int:
		fmt.Printf("x 是 int 型")
	case float64:
		fmt.Printf("x 是 float64 型")
	case func(int) float64:
		fmt.Printf("x 是 func(int) 型")
	case bool, string:
		fmt.Printf("x 是 bool 或 string 型")
	default:
		fmt.Printf("未知型")
	}
```
## 循环语句
### for
- 可以省略初始条件、终止条件、自增
- 全部省略之后相当于while
```go
func convertToBin(n int) string {
	result := ""
	for ; n > 0; n /= 2 {
		lsb := n % 2
		result = strconv.Itoa(lsb) + result
	}
	return result
}

func printFile(filename string) {
	file, err := os.Open(filename)
	if err != nil {
		panic(err)
	}

	printFileContents(file)
}
func forever() {
    for {
        fmt.Println("abc")
    }
}
//for range
for i, x := range numbers {
    fmt.Printf("第 %d 位 x 的值 = %d\n", i, x)
}
```